<!DOCTYPE html>
<html>
<head>
  <title>Gesture Extension</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      height: 100vh;
      font-size: 1.5em;
    }

    form {
      text-align: center;
    }

    label {
      /* display: block; */
      margin-bottom: 20px;
    }

    input,
    select {
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h1>Gesture Extension</h1>

  <form>

    <label for="date">Date:</label>
    <input type="date" id="date" name="date" onchange="saveState('date', this.value)"><br>

    <label for="checkbox">Case à cocher:</label>
    <input type="checkbox" id="checkbox" name="checkbox" onchange="saveState('checkbox', this.checked)"><br>

    <label for="radio">Bouton radio:</label><br>
    <input type="radio" id="radio1" name="radio" value="option1" onchange="saveState('radio', this.value)"><label for="radio1">Option 1</label><br>
    <input type="radio" id="radio2" name="radio" value="option2" onchange="saveState('radio', this.value)"><label for="radio2">Option 2</label><br>

    <label for="select">Sélection:</label>
    <select id="select" name="select" onchange="saveState('select', this.value)">
      <option value="option1">Option 1</option>
      <option value="option2">Option 2</option>
      <option value="option3">Option 3</option>
    </select><br>

    <label for="range">Plage:</label>
    <input type="range" id="range" name="range" min="0" max="100" onchange="saveState('range', this.value)"><br>

    <label for="color">Couleur:</label>
    <input type="color" id="color" name="color" onchange="saveState('color', this.value)"><br>

    <input type="submit" value="Soumettre">
  </form>

  <script>


// window.addEventListener("keydown", (event) => {
//       console.log( event )
//     });
    // document.addEventListener("wheel", (event) => {
    //   console.log( event )
    // });

    // window.dispatchEvent(new KeyboardEvent('keydown', {key: "Control",keyCode: 17, code: 'ControlLeft', location: 1, ctrlKey: true,}));
    // document.dispatchEvent( new WheelEvent( 'wheel',
    // {
    //     isTrusted: true,
    //     target: document,
    //     view: window,
    //     bubbles: true,
    //     cancelable: true,
    //     deltaX: 0,
    //     deltaY: -150,
    //     wheelDeltaX: 0,
    //     wheelDelta: 180,
    //     wheelDeltaY: 180,
    //     which: 0,
    //     composed: true,
    //     ctrlKey: true 
    // } ) );
//     document.addEventListener('wheel', function(e) {
//   e.ctrlKey && e.preventDefault();
// }, {
//   passive: false,
// });

//   window.dispatchEvent(new CustomEvent('scroll', {isTrusted: true, type: 'scroll', target: document, currentTarget: document, eventPhase: 2}))

    
    // Fonction pour enregistrer l'état de chaque input
    function saveState(inputName, value) {
      localStorage.setItem(inputName, value);
    }

    // Récupérer l'état enregistré lors du chargement de la page
    window.onload = function() {
      var inputs = document.getElementsByTagName('input');
      for (var i = 0; i < inputs.length; i++) {
        var input = inputs[i];
        if (input.type !== 'submit') {
          var savedValue = localStorage.getItem(input.name);
          if (savedValue) {
            if (input.type === 'checkbox') {
              input.checked = (savedValue === 'true');
            } else {
              input.value = savedValue;
            }
          }
        }
      }

      var select = document.getElementById('select');
      var savedOption = localStorage.getItem('select');
      if (savedOption) {
        select.value = savedOption;
      }
    };

//     const canvas = document.getElementById("canvas");
// const ctx = canvas.getContext("2d");

// function Particle(x, y, radius, color, velocity) {
//   this.x = x;
//   this.y = y;
//   this.radius = radius;
//   this.color = color;
//   this.velocity = velocity;
//   this.alpha = 1;

//   this.draw = function () {
//     ctx.save();
//     ctx.globalAlpha = this.alpha;
//     ctx.beginPath();
//     ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
//     ctx.fillStyle = this.color;
//     ctx.fill();
//     ctx.restore();
//   };

//   this.update = function () {
//     this.draw();
//     this.velocity.x *= 0.99;
//     this.velocity.y *= 0.99;
//     this.x += this.velocity.x;
//     this.y += this.velocity.y;
//     this.alpha -= 0.02;
//   };
// }

// function createExplosion(x, y) {
//   const particles = [];
//   for (let i = 0; i < 30; i++) {
//     const radius = Math.random() * 2 + 1;
//     const color = `hsl(${Math.random() * 360}, 50%, 50%)`;
//     const angle = Math.random() * Math.PI * 2;
//     const velocity = {
//       x: Math.cos(angle) * (Math.random() * 2),
//       y: Math.sin(angle) * (Math.random() * 2),
//     };
//     particles.push(new Particle(x, y, radius, color, velocity));
//   }

//   function animate() {
//     requestAnimationFrame(animate);
//     ctx.clearRect(0, 0, canvas.width, canvas.height);

//     for (let i = 0; i < particles.length; i++) {
//       if (particles[i].alpha > 0) {
//         particles[i].update();
//       } else {
//         particles.splice(i, 1);
//         i--;
//       }
//     }
//   }

//   animate();
// }

// canvas.addEventListener("click", (e) => {
//   const x = e.clientX - canvas.getBoundingClientRect().left;
//   const y = e.clientY - canvas.getBoundingClientRect().top;
//   createExplosion(x, y);
// });
  </script>
</body>
</html>
